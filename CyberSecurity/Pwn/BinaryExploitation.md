# Reverse Enginnering

- 正常情況下我們不容易取得執行檔的原始碼，所以我們很常需逆向分析程式尋找漏洞
- 種類
  - Static Analysis 靜態分析
    - Analyze program without running
    - 優點
      - 程式覆蓋範圍大
      - 可找到很多條程式執行路徑
    - 缺點
      - 不知該從那開始分析
      - 怎麼互動
    - 工具
      - objdump, IDA Pro
  - Dynamic Analysis 動態分析
    - Analyze program with running
    - 優點
      - 可以觀察到記憶體、暫存器的值
      - 精確的結果
    - 缺點
      - 程式覆蓋有限
      - 不知該怎麼模擬環境
    - 工具
      - GDB
      - strace
        - trace all system call
      - ltrace
        - trace all library call

# Exploitation
  
- 利用漏洞來達成攻擊者的目的
- 一般來說主要目的在於取得程式控制權
- 又稱 **pwn**
  - Binary Exploitaion
    - 專指與 binary 相關的漏洞利用
    - 兩大主流
      - 本地提權 (kernel mode)
      - Remote code execution (user mode)
- Useful Tool
  - IDA Pro - a static analysis tool
  - GDB - a dynamic analysis tool

LAB1
Section
- 在一般情況下程式碼會分成text、data以及bss等section，並不會將code和data混在一起使用
- `.text` : 存放code的section
- `.data` : 存放有初始值的全域變數
- `.bss` : 存放沒有初始值的全域變數
- `.rodata` : 存放唯讀資料的section
Execution
- Binary Format
  - 執行檔的格式會根據OS不同，而有所不同
  - Linux - ELF
  - Windows - PE
- Segment
  - 在Binary的開頭會有個magic number欄位，方便讓OS辨認是屬於什麼樣類型的檔案
    - 在Linux下可使用`file`來檢視
  - 在程式執行時才會有的概念，基本上會根據讀寫執行權限及特性來分為數個segment
  - 一般來說可分為rodata, data, code, stack, heap等segment
    - data : rw-
    - code : r-x
    - stack : rw-
    - heap : rw-
- Execution Flow
  - What happened when we execute an elf file?
    - `$ ./hello`
  - 在一般情況下程式會在disk中，而kernel會透過一連串的過程來將程式mapping到記憶體中去執行
    - Static linked
  
![](https://d2mxuefqeaa7sj.cloudfront.net/s_B234B9ACBB98ECA410EB56942730D69FEDB69AF30373EC2DF07D9B3FA89691B6_1504075842732_2017-08-30+14-50-30+.png)

    - Dynamic linked

![](https://d2mxuefqeaa7sj.cloudfront.net/s_B234B9ACBB98ECA410EB56942730D69FEDB69AF30373EC2DF07D9B3FA89691B6_1504075803715_2017-08-30+14-49-43+.png)

  - How program maps to virtual memory
    - 在program header中
      - 記錄著哪些segment應該mapping到什麼位置，以及該segment的讀寫執行權限
      - 記錄著哪些section屬於哪些segment
        - 當program mapping記憶體時會根據權限的不同來分成好幾個segment
        - 一個segment可以包含0到多個section
    - `readelf -l binary`
      - 查看program header
    - `readelf -S binary`
      - 查看section header
    - `readelf -d binary`
      - 查看dynamic section內容
  - `ld.so`
    - 載入elf所需要的shared library
      - 這部份會紀錄在elf的`DT_NEED`中
    - 初始化GOT
    - 進行其他相關初始化的東西
      - ex.將symbol table合併到global symbol table等等
    - 對實際運作有興趣可參考elf/rtld.c
    - 在`ld.so`執行完後會跳到_start開始執行主要程式
    - _start
      - 將下列項目傳給`libc_start_main`
        - 環境變數起始位置
        - `main`的位置(通常在第一個參數)
        - `.init`
          - 呼叫`main`之前的初始化工作
        - `.fini`
          - 程式結束前的收尾工作
    - `_libc_start_main`
      - 執行`.init`
      - 執行`main`
      - 執行`.fini`
      - 執行`exit`結束程式

- Hello World
  - `nasm -felf64 hello.s -o hello.o`
  - `ld -m elf_x86_64 hello.o -o hello`
    global _start
    
    section .text
    _start :
      xor rax,rax
      xor rbx,rbx
      xor rcx,rcx
      xor rdx,rdx
      jmp str
    write:
      mov rax,1 ;write
      inc rdi
      pop rsi
      mov rdx,12
      syscall
      
      mov rax,60 ;exit
      syscall  
    str:
      call write
      db 'Hello world', 0


- Shellcode
  - 顧名思義，攻擊者主要注入程式碼後的目的為拿到shell，故稱shellcode
  - 由一系列的machine code組成，最後目的可做任何攻擊者想做的事
  - Hello world shellcode
    - 產生：
    objcopy -O binary hello.bin shellcode.bin
    xxd -i shellcode.bin


  - Using Pwntool
    - http://docs.pwntools.com/en/stable/asm.html
  - Pwntool binutils
    - http://docs.pwntools.com/en/stable/install/binutils.html
  - Test your shellcode
    - `gcc -z execstack test.c -o test`
  - How to debug your shellcode
    - `gdb ./test`
  - orw64


Buffer Overflow
- Buffer Overflow
  - 程式設計師未對buffer做長度檢查，造成可以讓攻擊者輸入過長的字串，覆蓋記憶體上的其他資料，嚴重時更可控制程式流程
  - 依照buffer位置可分成
    - stack base (又稱stack smashing)
    - data base
    - heap base
  - Vulnerable functions
    - gets/scanf/strcpy/sprintf/memcpy/strcat/...
  - From crash to explolit
    - 隨意任意輸入一堆資料應該只能造成crash
    - 需適當的構造資料，就可巧妙的控制程式流程
    - e.g.
      - 適當的構造return address就可在函式返回時，跳到攻擊者的程式碼
    - Overwrite the return address
    - 因x86底下是little-endian的，所以填入address，需要反過來填入
    - e.g.
      - 假設要填入`0x00400646`就需要填入`\x64\x06\x40\x00\x00\x00\x00\x00`
      - `p64(0x400646) # in pwntools`
- Return to Text
  - 控制eip後跳到原本程式中的程式碼
  - 以bofeasy範例來說，我們可以跳到`l33t`這個function
  - 可以`objdump`, `nm`來找尋函式的真正位置
  - Exploitation
    - Locate the return address
      - 可用aaaaaaaabbbbbbbb…八個一組的字來定位return address
      - pwntools `cyclic`
      - gdb-peda `pattc`
    - Write exploit
      - `echo -ne` `"``aaaaaaaabbbbbbbbccccccccddddddddeeeeeee\x46\x60\x40\x00\x00\x00\x00\x00``"` > exp
      - cat exp - | ./bofeasy
    - Debug exploit
      - `gdb$ r < exp`
      - Use attach more would be easier
- Return to Shellcode
  - 如果在data段上是可執行且位置固定的話，我們也可以先在data段上塞入shellcode跳過去
- Protection
  - ASLR
    - 記憶體位置隨機變化
    - 每次執行程式時，stack, heap, library位置都不一樣
    - 查看是否有開啟ASLR
      - `cat /proc/sys/kernel/randomize_va_space`
    - 使用`ldd`(可看執行時載入的binary及其位置)觀察address變化
  - DEP
    - 又稱NX
    - 可寫的不可執行，可執行的不可寫
  - PIE(Position Independent Execution)
    - `gcc`在預設情況下不會開啟，編譯時加上`-fPIC -pie`就可以開啟
    - 在沒開啟的情況下程式的data段及code段會是固定的
    - 一旦開啟之後data及code也會跟著ASLR，因此前面說的ret2text/shellcode沒有固定位置可以跳，就變得困難許多
    - `objdump`觀察pie開啟的binary
    - code address變成只剩下offset，執行後會加上code base才是真正在記憶體中的位置
  - StackGuard
    - 在程式執行時隨機生成一亂數，function call時會塞入stack中，在function return時會檢查該值是否有被更動，一旦發現被更動就結束該程式
    - 該值又稱canary
    - 非常有效地阻擋了stack overflow的攻擊
    - 目前預設情況下是開啟的
    - canary的值在執行期間都會先放在，一個稱為tls的區段中的`tcbhead_t`結構中，而在x86/x64架構下恆有一個暫存器指向tls段的`tcbhead_t`結構
      - x86 : `gs`
      - x64 : `fs`
      - 因此程式在取canary值時都會直接以fs/gs做存取
- Lazy binding
  - Dynamic linking的程式在執行過程中˙有些binary的函式可能到結束都不會被執行到
  - 所以ELF採取lazy binding的機制，在第一次call library的函式時，才會去尋找真正的位置進行binding
  - library的位置在載入後才決定，因此無法在compile後就知道library中的function在哪，該跳去哪
  - GOT為一個函式指標陣列，儲存其他binary中function的位置，但因Lazy binding的機制，並不會一開始就把正確的位置填上，而是填上一段plt位置的code
  - 當執行到library的function時才會真正去尋找funtion最後再把GOT中的位置填上真正的function位置
  - 分成兩部份
    - `.got`
      - 保存全域變數引用位置
    - `.got.plt`
      - 保存函式引用位置
      - 前三項有特別用途
        - address of `.dynamic`
        - `link_map`
          - 一個將有引用到的library所串成的linked list，function resolve時也會用到
        - `dl_runtime_resolve`
          - 用來找出函式位置的函式
      - 後面則是程式中`.so`函式引用位置
  - How to find the GOT
    - `objdump -R elf` or `readelf -r elf`
  - 為了實作Lazy binding的機制GOT位置必須是可寫入的
  - 如果程式有存在任意更改位置的漏洞，便可改寫GOT，造成程式流程的改變
    - 也就是控制RIP
  - RELRO
    - 分成三種
      - Disabled
        - `.got/.got.plt`都可寫
      - Partial (default)
        - `.got` 唯讀
      - Fulled
        - RELRO保護下，會在load time時將全部function resolve完畢
- Return to Library
  - 在一般正常情況下程式中很難會有system等，可以直接獲得shell的function
  - 在DEP/NX的保護下我們也無法直接填入shellcode去執行我們的程式碼
  - 而在Dynamic Linking情況下，大部份程式都會載入libc，libc中有非常多好用的function可以達成我們的目的
    - system/execve/…
  - 但一般情況下都會因為ASLR，導致每次libc載入位置不固定
  - 所以我們通常都需要information leak的漏洞來獲取libc的base address，進而算出system的function的位置，再將程式導過去
  - 通常可以獲得libc位置的地方
    - GOT
    - Stack上的殘留值
      - function return後並不會將stack中的內容清除
    - heap上的殘留值
      - `free`完之後再`malloc`，也不會將heap存的內容清空
  - 而一般的情況下ASLR都是整個library image一起移動，因此只要有leak出libc中的位址，通常都可以算出libc
  - 我們可以利用`objdump -T libc.so.6 | grep function`來找尋想找的function在libc中的offset
  - 如果我們獲得`printf`位置，可先找尋printf在libc中的offset，以及想要利用的function offset
  - 在獲得system位置之後，我們可以複寫return address跳到system上，這邊要注意的是參數也要一起放上
  - 但在x86-64 Linux上傳遞參數是用register傳遞的，第一個參數會放在`rdi`，所以我們必須想辦法將`/bin/sh`的位置放在`rdi`上
    - 可利用`pop rdi; ret`的方式將參數放到`rdi`
  - 補充：
    - `/bin/sh`字串位置也可以在libc中找到，因此當程式中沒有字串，可以從libc裏面找
    - `system`參數只要`sh`即可，因此也可以考慮只尋找`sh`字串
- Return-Oriented Programming
  - 透過ret去執行其他包含ret片段的程式碼
  - 這些片段又稱為gadget
  - Why do we need ROP
    - Bypass DEP
    - Static linking can do more thing
  - ROP chain
    - 在夠長的buffer overflow後stack的內容幾乎都由我們控制，我們可以藉由ret = pop rip指令，持續的控制rip
    - 由眾多的ROP gadget組成
    - 藉由不同的register及記憶體操作，呼叫system call達成任意代碼執行
    - 基本上就是利用ROP gadget來串出我們之前寫的shell code的效果
  - Gadget
    - read/write register/memory
      - `pop rax;pop rcx; ret`
      - `mov [rax],rcx; ret`
    - system call
      - `syscall`
    - change `rsp`
      - `pop rsp; ret`
      - `leave; ret`
  - Write to register
    - `pop reg; ret`
    - `mov reg, reg ; ret`
    - …
  - Write to memory
    - `mov [reg],reg`
    - `mov [reg+xx],reg`
    - ...
  - `execve(``"``/bin/sh``"``,NULL,NULL)`
    - write to memory
      - 將`"/bin/sh"`寫入記憶體中
      - 可分多次將所需字串寫入記憶體中
  - find gadget
    - https://github.com/JonathanSalwan/ROPgadget
    - `ROPgadget --binary binary`
    - `ROPgadget` `--``ropchain` `--``binary binary`
      - 在static linking通常可以組成功`execve`的ROP chain但通常都很長，需要自己找更短的gadget來改短一點
- Using ROP bypass ASLR
  - 假設dynamic編譯的程式中有Buffer Overflow的漏洞且在沒PIE的情況下(先不考慮StackGaurd的情況)
  - How to bypass ASLR and DEP?
    - Use `.plt` section to leak some information
      - ret2plt
    - 通常一般的程式中都會有`put`, `send`, `write`等output function
  - Bypass PIE
    - 必須比平常多leak一個code段的位置，藉由這個值算出code base進而推出所有GOT等資訊
    - 有了code base之後其他就跟沒有PIE的情況下一樣
  - Bypass StackGuard
    - canary只有在function return時做檢查
    - 只檢查cananry值是否一樣
    - 所以可以先想辦法leak出canary的值，塞一模一樣的內容就可bypass，或是想辦法不要改到canary也可以
    - Weakness in `fork`
      - canary and memory mapping are same as parent

PLT stands for Procedure Linkage Table which is, put simply, used to call external procedures/functions whose address isn't known in the time of linking, and is left to be resolved by the dynamic linker at run time.

GOT stands for Global Offsets Table and is similarly used to resolve addresses.